# lab5
Лабораторная работа демонстрирует применение многопоточности в C++ для ускорения обработки изображений. Реализованы последовательный и параллельный алгоритмы размытия изображения с использованием ядра 5×5, а также тест производительности атомарных операций по сравнению с мьютексами.

1. Размытие изображения
Алгоритм:
Применяется ядро свертки 5×5 (среднее арифметическое значений пикселей в области)
Для каждого пикселя вычисляется новое значение на основе соседних пикселей
Реализации:
sequentialBlur() - последовательная обработка
parallelBlurThreads() - параллельная обработка с разделением изображения на горизонтальные полосы

2. Тест атомарных операций
Сравнение производительности инкремента счетчика:
С использованием мьютекса (std::mutex)
С использованием атомарной операции (std::atomic)

Разделение данных
Изображение делится на N горизонтальных полос (по числу потоков). Каждый поток обрабатывает свою полосу независимо.

В данном случае синхронизация не требуется, так как:
Потоки работают с разными участками изображения
Исходное изображение только читается
Результирующее изображение записывается в непересекающиеся области

Время выполнения размытия (изображение 866x650)
Последовательное - 0.719834 секунд
Параллельное (4 потока) - 0.248892 секунд

Мьютексы - 0.422001 секунд
Атомарные операции - 0.129342 секунд

Многопоточность позволяет:
Распараллелить вычислительную нагрузку на несколько ядер процессора
Уменьшить общее время выполнения за счет одновременной обработки разных частей изображения
Полностью использовать вычислительные ресурсы современного CPU

Факторы, влияющие на ускорение:
Число доступных ядер процессора
Размер обрабатываемых данных
Накладные расходы на создание потоков

1. Гонка данных (Race condition)
Проблема: Несколько потоков пытаются изменить одни и те же данные одновременно
Решение:
Разделение данных между потоками (как в нашем случае)
Использование мьютексов для критических секций

2. Ложное разделение кеша (False sharing)
Проблема: Потоки работают с разными, но близко расположенными в памяти данными
Решение: Выравнивание данных или увеличение расстояния между обрабатываемыми блоками

3. Атомарные операции vs мьютексы
Атомарные операции:
Подходят для простых операций (инкремент, декремент)
Не требуют блокировок
Работают на уровне процессора

Мьютексы:
Подходят для сложных операций над общими данными
Требуют больше ресурсов
Могут приводить к блокировкам
